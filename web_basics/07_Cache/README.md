# キャッシュを理解する

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<details>
<summary>Table of Contents</summary>

- [課題1](#%E8%AA%B2%E9%A1%8C1)
  - [なぜキャッシュが必要なのか](#%E3%81%AA%E3%81%9C%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%AA%E3%81%AE%E3%81%8B)
  - [キャッシュの種類](#%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E3%81%AE%E7%A8%AE%E9%A1%9E)
  - [HTTPヘッダによるブラウザキャッシュの制御](#http%E3%83%98%E3%83%83%E3%83%80%E3%81%AB%E3%82%88%E3%82%8B%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E3%81%AE%E5%88%B6%E5%BE%A1)
  - [ブラウザごとのキャッシュサイズの違い](#%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%81%94%E3%81%A8%E3%81%AE%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E3%82%B5%E3%82%A4%E3%82%BA%E3%81%AE%E9%81%95%E3%81%84)
  - [動的サイトへの `Expires` ヘッダの是非](#%E5%8B%95%E7%9A%84%E3%82%B5%E3%82%A4%E3%83%88%E3%81%B8%E3%81%AE-expires-%E3%83%98%E3%83%83%E3%83%80%E3%81%AE%E6%98%AF%E9%9D%9E)
  - [ブラウザキャッシュの実例を3つ紹介](#%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%E3%81%AE%E5%AE%9F%E4%BE%8B%E3%82%923%E3%81%A4%E7%B4%B9%E4%BB%8B)
- [課題2](#%E8%AA%B2%E9%A1%8C2)
- [課題3](#%E8%AA%B2%E9%A1%8C3)
- [課題4](#%E8%AA%B2%E9%A1%8C4)

</details>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 課題1 

### なぜキャッシュが必要なのか

ネットワークでのキャッシュの利点を考えるために、まずはキャッシュがない世界がどのようなものなのか考える。

- サイズの大きいファイルをリクエストすると、毎回ブラウザとサーバ間で大量のラウンドトリップが発生する
  - ラウンドトリップ: ネットワークにおいてリクエストを行い、対応するレスポンスが返ってくるまでの過程のこと
  - ラウンドトリップの増加は、ネットワークの遅延などを引き起こす
- データ通信容量に制限がある場合、ネットワーク上のリソースと紐づくリソースをダウンロードする必要があり、通信制限に引っかかりやすくなる

上記のように様々な問題が発生してしまう。

しかし一度ダウンロードしたリソースに対して、次回以降ブラウザに保存されているキャッシュをうまく活用することで、ネットワーク帯域幅を余分に使用することなく、リソースを読み込む事ができる

これはコンピュータに搭載されているL2キャッシュやL3キャッシュの役割と似ており、これらはCPUの処理速度とハードディスクの処理速度の違いを吸収することで、メモリアクセスを高速化を実現している。

ネットワークにおけるキャッシュも似たような考え方に基づいている。

- 参考資料
  - [Prevent unnecessary network requests with the HTTP Cache](https://web.dev/http-cache/)

---

### キャッシュの種類

キャッシュは大きく分けて **プライベートキャッシュ** と **共有キャッシュ** というカテゴリーに分類する事ができる。

- プライベートキャッシュ
  - 特定のユーザーに対して、リソースの配信などを高速化するために使用される
  - **HTTP** でダウンロードした全ての文書を保持する
  - 保持された文書を使用することで、サーバと追加のやりとりを行う必要なく、ブラウザの戻るやページ保存、ソースの表示といった各種機能を実現する
- 共有キャッシュ
  - 複数のユーザーに対して、再利用されるリソースへのアクセスの高速化のために使用される
  - プロキシにキャッシュを保存することで、ISPや企業は何度もアクセスされるリソースに対するトラフィックや遅延の低減を実現できる

> MDNではこの2つが記載されていたが、他にもキャッシュの種類は存在しているのか

参考資料
　
- [[MDN] HTTP Cache](https://developer.mozilla.org/ja/docs/Web/HTTP/Caching)

---

### HTTPヘッダによるブラウザキャッシュの制御

HTTPリクエストを送信するときの流れは以下になる。

1. HTTPリクエストを発行する
2. ブラウザのキャッシュにルーティングされる
3. ブラウザのキャッシュがリクエストの要求を満たすのか検証する
   - Yes: レスポンスをキャッシュから読み出す
   - No: サーバにリクエストを転送する

上記の中で、ブラウザキャッシュに対して何を検証するのかは、リクエストヘッダとレスポンスヘッダで制御する事が可能である。

ではそれぞれのヘッダでどのような制御が可能なのか見ていく

#### リクエストヘッダ

リクエストヘッダの特徴としては、リクエストを送信する際にブラウザが **自動的**　にキャッシュに対して制御を行うためのヘッダを付与する点である。

これで HTML ファイル内に `<img src="cat.png">` が存在していたとしても、ブラウザが自動的に保存されているキャッシュに対して制御を実行する。

ブラウザが設定するヘッダは以下になる。

- `If-None-Match`
  - 図解
- `If-Modified-Since`
  - 図解

なお Fetch API などを使用してリクエストを発行する場合には、リクエストヘッダにキャッシュに対する制御を行う事ができる。

```js
fetch("http://localhost:8080", {
  cache: "no-store"
})
```

Fetch API で設定できるキャッシュの種類は以下になる。

| キャッシュ値     | 内容                                                                                                                                                                                                                                                                                                                                                                                                                     | 
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | 
| `default`        | ブラウザは、リクエストの要求を満たすリソースがHTTPキャッシュに存在するのか検証する<br><br>* match & fresh<br>⇨ HTTPキャッシュが返される<br>* match & stale<br>⇨ サーバに条件付きリクエストを送信し、中身が変化していればサーバからリソースが返され、中身が同じならばHTTPキャッシュが返される<br>* dismatch<br>⇨ 通常のリクエストを送信し、HTTPキャッシュを新たなリソースで更新する                                    | 
| `no-store`       | ブラウザはHTTPキャッシュを確認せずにリクエストをサーバに送信する<br><br>HTTPキャッシュを新たなリソースで **更新することはしない**                                                                                                                                                                                                                                                                                        | 
| `reload`         | ブラウザはHTTPキャッシュを確認せずにリクエストをサーバに送信する<br><br>HTTPキャッシュを新たなリソースで**更新する**                                                                                                                                                                                                                                                                                                     | 
| `no-cache`       | ブラウザは、リクエストの要求を満たすリソースがHTTPキャッシュに存在するのか検証する<br><br>* match & (fresh &#124; stale)<br>⇨ 条件付きリクエストをサーバに送信する。<br>中身が同じ場合はHTTPキャッシュからリソースが返される<br>中身が異なる場合は新たなリソースがダウンロードされ、HTTPキャッシュも更新される<br>* dismatch<br>⇨ 通常のリクエストを送信して新たなリソースをダウンロードし、HTTPキャッシュも更新される | 
| `force-cache`    | ブラウザは、リクエストの要求を満たすリソースがHTTPキャッシュに存在するのか検証する<br><br>* match & (fresh &#124; stale)<br>⇨ HTTPキャッシュが返される<br>* dismatch<br>⇨ 通常のリクエストを送信して新たなリソースをダウンロードし、HTTPキャッシュも更新される                                                                                                                                                         | 
| `only-if-cached` | ブラウザは、リクエストの要求を満たすリソースがHTTPキャッシュに存在するのか検証する<br><br>* match & (fresh &#124; stale)<br>⇨ HTTPキャッシュが返される<br>* dismatch<br>⇨ ブラウザは504 Gateway Timeout のステータスコードを返す<br><br>リクエストの mode が、`same-origin` の場合にのみ使用される                                                                                                                     | 

参考資料

- [[MDN] If-None-Match](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/If-None-Match)
- [[MDN] If-Modified-Since](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/If-Modified-Since)
- [[MDN] HTTP条件付きリクエスト](https://developer.mozilla.org/ja/docs/Web/HTTP/Conditional_requests)
- [[MDN] Request.cache](https://developer.mozilla.org/en-US/docs/Web/API/Request/cache)

#### レスポンスヘッダ

サーバ側が設定するレスポンスヘッダによって、HTTPキャッシュを制御する事が可能である。

主に使用されるHTTPヘッダは以下の3種類である。

- `Cache-Control`
  - この HTTP ヘッダを使用する事で、ブラウザがキャッシュをどのように、またどの程度の期間保存するのか制御する事ができる
- `ETag`
  - サーバのリソースに対して小さな Token を割り当てる
  - ブラウザからのレスポンスで、HTTP キャッシュの該当する値を送信することで、対象リソースが変更されているのか検証できる
- `last-Modified`
  - 目的自体は `ETag` と同じではあるが、リソースに対して有効期限を設定することで HTTP キャッシュを制御する

デフォルトでどのような値が設定されるのかは、使用しているWebアプリケーションに応じて異なっている。

なお `Cache-Control` ヘッダを省略しても HTTP キャッシュが無効になるわけではない。ブラウザが特定のタイプのコンテンツに対して、どのタイプのキャッシュ制御が適用できるのか効率的に推測している。



参考資料

- [[MDN] Cache-Control](https://developer.mozilla.org/docs/Web/HTTP/Headers/Cache-Control)
- [[MDN] ETag](https://developer.mozilla.org/docs/Web/HTTP/Headers/ETag)
- [[MDN] Last-Modified](https://developer.mozilla.org/docs/Web/HTTP/Headers/Last-Modified)
- [[Express] express.static](https://expressjs.com/en/api.html#express.static)
- [[Nginx] ngx_http_headers_module](http://nginx.org/en/docs/http/ngx_http_headers_module.html)

---

### 実際に設定するレスポンスヘッダの値



### ブラウザごとのキャッシュサイズの違い

### 動的サイトへの `Expires` ヘッダの是非

### ブラウザキャッシュの実例を3つ紹介

## 課題2

以下の条件に従うサーバを構築する。

- 何かしらの画像を返す
- 2つのエンドポイントを用意する
  - 1つ目: 同じクライアントからのアクセスの場合、キャッシュを使用してアクセス負荷を減らす
  - 2つ目: ブラウザキャッシュを使用せずに画像を返す

## 課題3

ブラウザキャッシュを使うべきではないケースを3つ考える。

- どんなサービスの？
- どんなページで？
- どんなファイルを？
- キャッシュしてはいけないのでしょうか？

## 課題4

クイズ








